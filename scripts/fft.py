#!/usr/bin/env python3

import numpy as np
import pandas as pd
import math
from numpy.fft import *


def init_grid(N, mesh_size = 1):
    """
        INITIALIZES GRID FOR FFT
        INPUT :
            N(int) size of the grid
            mesh_size(float) mesh size
        OUTPUT :
            grid(pandas dataframe) 4 columns (x,y,z, resloc)
    """
    x = []
    y = []
    z = []
    for i in np.arange(0,N+mesh_size, mesh_size):
        for j in np.arange(0,N+mesh_size, mesh_size):
            for k in np.arange(0,N+mesh_size, mesh_size):
                x.append(i)
                y.append(j)
                z.append(k)

    resloc = [0] * len(x)
    grid = np.array((x, y, z, resloc), dtype=int)
    grid = pd.DataFrame(grid.transpose())
    return(grid)

def dist_cal(x1, y1, z1, x2, y2, z2):
    """
        CALCULATES DISTANCE BETWEEN TWO POINTS IN 3D
        INPUT :
            x1(float)
            y1(float)
            z1(float)
            x2(float)
            y2(float)
            z2(float)
        OUTPUT :
            dist(float)
    """
    dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2 + (z1 - z2)**2)
    return(dist)

def fill_grid2(grid, coords):
    tot = len(grid.index)
    for i in range(0,len(grid.index)):
        for j in range(0, len(coords.index)):
            print(i/tot*100)
            if grid.iloc[i,0] == coords.iloc[j,0] and grid.iloc[i,1] == coords.iloc[j,1] and grid.iloc[i,2] == coords.iloc[j,2]:
                grid.iloc[i,3] = coords.iloc[j,3]

    return(grid)


def fill_grid(grid, coords, resolution):
    """
        FILL GRID FOR FFT ACCORDING TO RESIDUE POSITION AND DEPTH
        INPUT :
            grid(pandas dataframe) empty grid generated by init_grid() function
            coords(pandas dataframe) residue coordinates (x,y,z) and depth from read scale_coords() function
            resolution(float) mesh size
        OUTPUT :
            grid(pandas dataframe) grid for FFT with 1 for points at surface, -1 for points in the core, 0 for points outside
    """
    dist = 0
    tot = len(grid.index)
    for i in range(0,len(grid.index)):
        flag = False
        for j in range(0, len(coords.index)):
            print(i/tot*100)
            dist = dist_cal(x1 = grid.iloc[i,0], y1 = grid.iloc[i,1], z1 = grid.iloc[i,2], x2 = coords.iloc[j,0], y2 = coords.iloc[j,1], z2 = coords.iloc[j,2])
            if dist < (resolution/2):
                print("dist",dist)
                print("coords : ",coords.iloc[j,:])
                grid.iloc[i,3] = coords.iloc[j,3]
                flag = True
                break
                # if coords.iloc[j,3] == 1:#surface
                #     # grid.iloc[i,3] = 1
                #     grid.iloc[i,3] = 1
                #     print("grid : ", grid.iloc[i,:])
                #     flag = True
                #     break
                # elif coords.iloc[j,3] == -1:# inside prot
                #     # grid.iloc[i,3] = -1
                #     grid.iloc[i,3] = 2
                #     flag = True
                #     break
        if flag == False:
            # grid.iloc[i,3] = 0 # outside
            grid.iloc[i,3] = 0
            # print("grid : ", grid.iloc[i,:])
    # grid = grid.as_matrix()
    return(grid)

def make_fft(rec_grid, lig_grid, L):
    tmp = ((1/L**3) *ifftn(np.dot(ifftn(rec_grid),fftn(lig_grid))))
    sc = tmp.real - tmp.imag
    return(sc)



if __name__ == "__main__":
    mygrid = init_grid(65)
